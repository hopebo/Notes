# In Search of an Understandable Consensus Algorithm

## Abstract
Raft是一种管理备份日志的一致性算法，它能达到和Paxos相似的效果，但是却有着更好的理解性。Raft的关键在于将一致性算法分为了几个模块，包括leader选举、日志备份和正确性。它保证了一个更高强度的一致性来减少必须考虑到的状态。

## 1 Introduction
与其他一致性算法相比，Raft有一些新奇的特征：
- 更强的leader：例如，日志记录只会从leader流向其他server。这大大简化了备份日志的管理。
- leader选举：Raft使用随机时间来进行选举。这种方式只是在心跳机制上稍微增加了额外负担，却能够很快很容易的解决冲突。
- 组员变化：在集群成员的变化过程中，两个不同配置中的大多数成员可能会发生重叠，Raft采用了一种联合一致性算法的方式来进行过渡。

## 2 Replicated state machines
备份状态机能够通过同样的拷贝独立计算，得到相同的状态，即使集群中一些机器挂掉了，也能继续工作。

备份状态机通常采用备份日志的方式进行实现。每一台server都存储着包含一系列命令的日志，不同server中对应日志中的命令和顺序是一致的。所以不同的状态机按照顺序执行后得到的状态也是确定一致的。

一致性算法的任务就是保持备份日志的一致性。一台server的一致性模块接收来自客户端的命令并将其加入到日志中，同时它与其他server的一致性模块进行通信来保证每一条日志最终按照相同的顺序包含相同的请求。

### 实际系统中一致性算法的特征
- 在所有非拜占庭条件下（包括网络延迟、分区、包丢失、包重复、乱序），能够保证返回结果的正确性。
- 只要一个集群中的大多数机器是可用的，在功能上它们就是可用的。
- 不依赖于时间来保证日志的一致性。
- 通常情况下，一个命令完成只需要集群中的大多数机器完成了相应的操作。

## 3 The Raft consensus algorithm
Raft实现一致性的方式是，首先选择一个leader，然后给予leader完全的责任去管理备份日志。leader接收来自客户端的请求，然后将日志备份在其他server上，并且告诉其他server什么时候能够安全的将日志应用到它们的状态机上。leader简化了日志备份管理的过程，因为leader不用和其他server协商，就可以决定在哪里存放新的日志记录。

有了leader的机制，我们就可以将一致性问题划分为三个相对独立的子问题：
- leader选举：当现存的leader宕机以后，一个新的leader必须被选举。
- 日志备份：leader必须接收来自客户端请求的日志记录，然后在集群上进行备份。同时强制其他server的日志和它保持一致。
- 正确性：如果任何server已经将一条日志记录应用到状态机，那么对于相同索引，没有其他机器会应用一条其他命令。

### 3.1 Raft basics
任何时候集群中的server状态处于三种状态中的一种：leader、follower和candidate。

Follower是被动的，它们从来不会主动发出请求，只是回复来自leader和candidate的请求。leader处理所有来自客户端的请求（如果用户联系到了一个follower，那么follower会将这个请求重定向到leader）。

Raft将时间划分为任意长度的term，每一个term都由选举开始，在这期间，一个或者多个candidate尝试成为leader。如果在一次选举中，票数被分散，不存在大多数票，那么会重新选举。
- 当一个follower失去通信的时候，它变成一个candidate并初始化选举。
- 获得大多数集群投票的备选变成新的leader。
- leader运转直到它们宕机。

每一个server都会存储一个当前term的数值，它是随着时间单调递增的。当前term是在server通信期间不断交换的。当服务器通信时，发现自己的term数较小，会自动更新会较大的term；如果candidate或者leader发现自己的term已经过期，会立即转换为follower状态。

### 3.2 Leader election
Raft使用心跳机制来触发leader选举。当server启动时，初始化状态为follower；只要它收到来自leader或者candidate有效的RPC通信，那么就会保持follower状态。Leader会像所有的follower周期性的发送AppendEntries RPC(但是日志记录为空)来保持leader的权威。如果一个follower在周期性时间内(election timeout)没有收到任何通信，那么它会认为没有有效的leader，会立即开始选举。

当开始一个选举时，follower增加了它的当前term并且转换为candidate状态，然后并发向集群中的其他server发送RequestVote RPC请求进行投票。投票的结果有三种：
1. 它赢得了选举
   如果一个candidate在相同term内获得了集群中大多数server的投票，那么它就会赢得了选举。在给定的term内，每个server最多给一个candidate进行投票。因此保证了最多只有一个candidate能够选举胜出，一旦一个candidate赢得选举，它会向其他server发送心跳信息来建立权威并且阻止新的选举。

2. 另一个server成为了leader
   当等待投票时，一个candidate可能受到其他宣布是leader的server发送AppendEntries RPC。如果leader的term大于当前选举的candidate，那么candidate会转变为follower；反之，candidate会拒绝请求并继续保持在candidate状态。

3. 一个周期性的时间内，没有server赢得选举
   同一时间，可能多个server都开始了选举，导致了票数被分散，没有形成大多数票。Raft使用随机选举超时来尽量避免这一情形，使得在绝大多数情况下，只有一台server会选举超时。

### 3.3 Log replication
Leader接收客户端请求，将命令作为一条新的记录加入到日志中，然后调用AppendEntries RPC并发向集群中其他server发出请求来备份这条日志记录。当日志记录被安全的备份后，leader才会apply这条记录到它的状态机并且返回结果到客户端。

一条日志被committed当创建这条日志的leader已经将其在大多数机器上进行了备份，也会将之前所有的日志进行commit，包括被之前的leader创建的。leader也会在心跳机制中带有它知道的被commit日志的最大index，一旦follower知道某条日志被commit了，它也会按照日志顺序commit到状态机。

Raft在日志备份过程中维护了两个属性：
- 如果两条在不同日志中的记录有着相同的索引和term，那么他们存储着相同的命令。
  Leader在给定term，对于一个index，最多创建一条日志记录。日志也从来不会改变它在日志中的位置。
- 如果两条在不同日志中的记录有着相同的索引和term，那么前面的日志记录一定是一样的。
  当leader发起AppendEntries RPC时，leader会带上前一条日志的index和term。follower会检查自己的日志，如果没有对应index和term的日志，它会拒绝新的日志记录。

Leader的crash可能会导致和follower的日志不一致。Raft处理这种不一致的方式是通过强制follower复制leader日志来解决的，在心跳机制中，当leader发现和follower的日志不一致时，会依次往前检查日志的一致性，直到找到最晚的一致的日志，然后follower的日志会被leader上的日志所覆盖。

### 3.4 Safety
这一节讲述了server在什么限制条件下会被选举为leader，这种限制决定了不管在哪个term中被选举为leader的server都包含之前term中所有被committed的日志条目。

Raft使用投票机制来保证这个条件，因为一个candidate至少联系大多数server来支持，大多数原则保证这些机器中至少有一台包含所有被commit的日志。通过RequestVote RPC就可以实现这个限制：在发送请求的时候，带上了candidate的日志信息，只有当candidate上的日志比其他机器的日志更新，其他机器才会给candidate投票。

leader只会根据多数派原则来commit当前term中的日志。一旦当前term中的某条日志被commit了，意味着它之前的日志也间接的被commit了，由于日志匹配的规则。
