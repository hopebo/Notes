# Apache Calcite: A Foundational Framework for Optimized Query Processing Over Heterogeneous Data Sources

## Abstract
Apache Calcite是一个基础软件框架，给多种流行的数据源提供了查询处理、优化、查询语言支持的功能。包括内置优化规则的现代可拓展的优化器框架，支持各种各样数据源（关系型、半结构化、流式、地理位置）的适配器架构。

## Introduction
定制化引擎的集合正在越来越流行，包括列式存储、流式处理、文本搜索引擎，因为定制化引擎能够带来更低的成本和更高效的性能。这带来了两个问题：
1. 这些数据系统的开发者们都面临同样的查询优化的问题，或者需要对SQL语句进行支持。重复开发类似的优化逻辑是一种浪费。
2. 这些数据系统中的数据有时需要进行集成。

Apache Calcite解决了这些问题，它是一个完整的查询处理系统，包含了大部分的共同功能（查询语言、查询优化与执行），除了数据存储与管理的工作留给了定制化引擎。

Orca通过实现了一个数据交互的框架来接耦合优化器和查询执行引擎。与Orca相比，Calcite能够作为独立的查询处理引擎来使用，通过联邦多个存储引擎和处理后台。

Calcite的查询优化器使用基于火山模型的动态规划，以及多阶段优化的方式。通过在关系型数据模型中表示半结构化数据的方式来支持半结构化数据模型。

## Architecture
Calcite不包含下列功能：数据存储、数据处理算法以及元数据存储仓库。使得Calcite能够完美的存在于包含一个或多个数据存储位置的应用之间。

Calcite使用关系算子的树来作为内部结构的表示，优化器引擎主要由规则、元数据提供者和计划引擎所组成。首先，Calcite包含查询解析器和验证器来将SQL查询转化为关系算子的表达树。由于Calcite本身不包含存储层，所以它提供了一个适配器机制来定义外部存储引擎中的表和视图定义。
1. 对于一些系统支持SQL查询，但是没有优化器功能的数据系统，Calcite可以将查询优化为关系算子树后，再转换回SQL，这一特性使得Calcite能够独立工作在任何支持SQL的系统之上。
2. Calcite的架构并不仅仅针对于优化SQL查询，也可以优化那些有着自己的解析器和查询语言的数据系统。通过接口能够直接的实例化关系算子树，暴露出基本必要的结构来建造关系表达式，经过优化之后，外部应用能够获取优化后的关系表达式，然后重新映射回系统的查询表达式单元。

## Query Algebra
### Operators
关系算子表达式是Calcite的核心，除了一些公共的操作符（过滤、映射、连接），还包含了额外的操作符来适应不同的需求，包括能够准备表示复杂操作符，或者更高效地识别优化机会。

### Traits
Calcite并不区别表示逻辑算子和物理算子的实体，而是通过将算子与特性结合起来表示操作符的物理属性，改变一个算子的特性并不改变计算的逻辑表达式。在优化过程中，Calcite可能尝试增强关系型表达式的某些属性，关系算子通过实现转换器来表示如何从一个特性转换成另一个。

针对每一个特性，会给明具有该特性的原因，并根据引擎的实际特征来避免不必要的操作。

## Adapters
适配器是一种架构模式，Calcite通过适配器可以吸收不同的数据源来做通用的访问。适配器由数据模型、定义和定义工厂组成，数据模型是被访问的数据源的物理属性；定义是数据的定义（格式和展示）；格式工厂从数据模型中获取元数据。

Calcite使用称作调用转换的物理特性来表示对应到特定数据库后端的关系型操作符，这些操作符实现了每个适配器中表的访问路径。

Calcite能够下推所有可能的逻辑到后端，然后在结果数据上完成连接和聚合。

## Query procssing and optimization
查询优化器是Calcite框架中主要的部件，Calcite不断将计划规则应用到关系表达式上，通过代价模型来引导这一过程，计划引擎尝试生成一个可替换的表达式，与原来有着相同的语义但是更低的代价。优化器中的每个组件都是可拓展的，用户能够增加关系型操作符、规则、代价模型和统计数据。

### Planner rules
Calcite包含一系列计划规则来转换表达式树，一个规则匹配树中的指定模式，然后进行一个转换来保留原表达式的语义。不同的系统可以根据其数据模型的特征来定义自己的转换规则。

### Metadata providers
元数据是Calcite优化器中的重要部分，有着两方面作用：
1. 引导优化器往减少全局执行计划代价减少的方向进行；
2. 给规则应用时提供必要的信息。

这些数据包括子树的执行代价、返回数据集大小和并行度。

### Planner engines
基于代价估算的计划引擎使用类似于火山模型的动态规划算法，有两种方式：
1. 贪婪式地探索搜索空间，直到所有的规则都被应用到所有的表达式上。
2. 使用启发式的规则，当在上一次迭代中代价减少没有超过阈值时停下。

### Materialized views
引擎将物化后的视图暴露给Calcite，借助物化视图可以将关系子树用相同的表达式替换。

## Industry and acamedia adoption
Calcite的应用有两种方式，第一种是将Calcite嵌入到内核，比如用作一个库；第二种实现适配器来让Calcite来联邦查询处理。
